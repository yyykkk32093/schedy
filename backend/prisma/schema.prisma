generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---- OutboxEvent テーブル定義 ----

model OutboxEvent {
  id             String    @id
  idempotencyKey String    @unique
  aggregateId    String
  eventName      String
  eventType      String
  routingKey     String
  payload        Json
  occurredAt     DateTime
  publishedAt    DateTime?
  status         String    @default("PENDING")

  retryCount  Int      @default(0)
  nextRetryAt DateTime @default(now())

  @@index([status, nextRetryAt])
}

model OutboxRetryPolicy {
  routingKey   String @id // Handler に対応する routingKey
  maxRetries   Int    @default(5) // 最大リトライ回数
  baseInterval Int    @default(3000) // 初期インターバル（ms）
  maxInterval  Int    @default(60000) // インターバル上限（ms）

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AuditLog {
  id             String   @id
  idempotencyKey String   @unique //  = OutBoxイベントのid String  @id
  eventType      String
  userId         String
  authMethod     String
  detail         String?
  occurredAt     DateTime
  createdAt      DateTime @default(now())
}

model OutboxDeadLetter {
  id String @id @default(uuid())

  outboxEventId String
  routingKey    String
  eventType     String

  payload      Json
  errorMessage String?
  errorStack   String?

  occurredAt DateTime // 元イベントの発生時刻
  failedAt   DateTime @default(now())
}

model Activity {
  id          String   @id @default(uuid())
  title       String
  description String?
  startAt     DateTime
  endAt       DateTime
  location    String?
  createdBy   String

  status String // 'ACTIVE' | 'CANCELLED'

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdBy])
  @@index([startAt])
  @@index([status])
}

model User {
  id                  String  @id @default(uuid())
  displayName         String?
  role                String  @default("MEMBER")
  email               String? @unique
  phone               String?
  avatarUrl           String?
  biography           String?
  notificationSetting Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  passwordCredential PasswordCredential?
  googleCredential   GoogleCredential?
  lineCredential     LineCredential?
  appleCredential    AppleCredential?

  authSecurityState AuthSecurityState?
}

model AuthSecurityState {
  userId String @id @map("user_id")

  /**
   * 最後に成功した認証方式（例: password/google/line/apple）
   */
  authMethod String? @map("auth_method")

  /**
   * 最終ログイン成功時刻（結果整合の投影）
   */
  lastLoginAt DateTime? @map("last_login_at")

  /**
   * セキュリティ判定向け（最小）
   */
  failedSignInCount Int       @default(0) @map("failed_sign_in_count")
  lockedUntil       DateTime? @map("locked_until")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([lockedUntil])
  @@map("auth_security_states")
}

model PasswordCredential {
  userId         String   @id
  hashedPassword String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model GoogleCredential {
  userId    String   @unique
  googleUid String   @unique
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model LineCredential {
  userId    String   @unique
  lineUid   String   @unique
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AppleCredential {
  userId    String   @unique
  appleUid  String   @unique
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}
